<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}

pre{
    border:1px solid #edc5c4;
}

.markdown-body th {
  padding: 0;
  text-align:left;
  background-color: #f1f0f0 !important;
}

.markdown-body td {
  font-size: 14px;
}
.markdown-body td pre{
  font-size: 12px;
  color: #039BE5;
  background-color: transparent; !important;
}

.markdown-body th, td pre{
  border: 0;
  background-color: transparent; !important;
}

.markdown-body blockquote {
   border-left: 4px solid #f48684 !important;

}</style><title>readme-new-client</title></head><body><article class="markdown-body"><h1 id="taildmp-sdk-android">TAILDMP SDK ANDROID</h1>
<blockquote>
<p>O TailDMP SDK é uma biblioteca utilizada para colher e enviar dados sobre dispositivos móveis que serão utilizados pela TailTarget.
A biblioteca fornece um mecanismo de automatização de coleta e envio dos dados, bastando definir a periodicidade entre os envios.  </p>
</blockquote>
<h2 id="configura-es-requeridas">Configurações requeridas</h2>
<h4 id="arquivo-de-configura-o">Arquivo de configuração</h4>
<p>Crie um arquivo chamado <em>TailDMPConfig.json</em>, ele deve estar salvo na pasta assets do projeto e deve conter o accountId.</p>
<p>Ex.</p>
<pre><code>{
  &quot;accountId&quot;: &quot;TT-0000-0&quot;
}
</code></pre><h4 id="permiss-es-no-androidmanifest">Permissões no AndroidManifest</h4>
<p>Adicionar as seguintes permissões ao <em>AndroidManifest.xml</em></p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
&lt;uses-permission android:name=&quot;com.google.android.gms.permission.ACTIVITY_RECOGNITION&quot; /&gt;
</code></pre><p>Adicionar os serviços abaixo dentro da tag aplication</p>
<pre><code>&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPCollectDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Collect Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendALLDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send All Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPActivityTrackerIntentService&quot; android:exported=&quot;false&quot; android:label=&quot;Tail DMP Activity Service&quot; /&gt;
</code></pre><p>O Arquivo <em>AndroidManifest.xml</em> ficará semelhante a este:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;tail.digital.app&quot; &gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
    &lt;uses-permission android:name=&quot;com.google.android.gms.permission.ACTIVITY_RECOGNITION&quot; /&gt;
    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot; &gt;
        &lt;activity android:name=&quot;.MainActivity&quot; &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
           &lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send Data Service&quot;/&gt;
        &lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPCollectDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Collect Data Service&quot;/&gt;
        &lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendALLDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send All Data Service&quot;/&gt;
        &lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPActivityTrackerIntentService&quot; android:exported=&quot;false&quot; android:label=&quot;Tail DMP Activity Service&quot; /&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><h4 id="adicionar-biblioteca-aar-no-projeto">Adicionar Biblioteca AAR no projeto</h4>
<p>Nossa biblioteca é distribuida pelo mavencentral.</p>
<p>A biblioteca do SDK já incorpora a seguinte biblioteca em seu pacote:</p>
<ul>
<li>com.google.code.gson:gson:2.8.0</li>
</ul>
<p>Caso você já a utilize em seu projeto exclua-a de seu arquivo gradle.build para evitar possíveis conflitos de compilação.</p>
<h4 id="configura-es-graddle">Configurações graddle</h4>
<p>Para o correto funcionamento do SDK precisamos modificar o arquivo &quot;build.gradle&quot; do projeto para compilar bibliotecas do play service e a do SDK.</p>
<p>A versão minima da Android requerida para o funcionamento do SDK é a <strong>4.0 (api 14)</strong>, o mecanismo de automatização de coleta e envio dos dados está disponível apenas nas versões maiores que <strong>5.0 (api 20)</strong>.</p>
<p>Ex.</p>
<pre>
defaultConfig {
    applicationId "tail.digital.app"
    minSdkVersion <b>14</b>
    targetSdkVersion <b>25</b>
    versionCode 1
    versionName "1.0"
}
</pre>


<p>Para o correto funcionamento do SDK utilizamos bibliotecas do google play service, elas devem ser compiladas junto ao aplicativo.
Devemos adicionar as bibliotecas play-services-identity:10.2.4, play-services-location:10.2.4 e incorporar o SDk como dependências do <em>gradle.build</em>.
Abaixo um exemplo de como ficaria a configuração do dependencies do arquivo <em>gradle.build</em>.</p>
<p>Ex.</p>
<pre>
dependencies {


    //import google play libs
    <b>compile 'com.google.android.gms:play-services-identity:10.2.4'</b>
    <b>compile 'com.google.android.gms:play-services-location:10.2.4'</b>
    //get sdk from maven central
    //change 1.2.+ to the latest version available
    <b>compile 'digital.tail.sdk.tail_mobile_sdk:tail-mobile-sdk:1.2.+'</b>

}
</pre>



<h4 id="abaixo-um-exemplo-de-como-ficaria-o-gradle-build">Abaixo um exemplo de como ficaria o gradle.build</h4>
<p>Ex.</p>
<pre>
apply plugin: 'com.android.application'
android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
    defaultConfig {
        applicationId "tail.digital.app"
        minSdkVersion <b>14</b>
        targetSdkVersion <b>25</b>
        versionCode 1
        versionName "1.0"

    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    //import google play libs
    <b>compile 'com.google.android.gms:play-services-identity:10.2.4'
    compile 'com.google.android.gms:play-services-location:10.2.4'</b>
    compile 'com.android.support:appcompat-v7:25.3.1'
    compile 'com.android.support.constraint:constraint-layout:1.0.2'
    //add and extract the sdk from mavencentral
    //change 1.2.+ to the latest version available
    <b>compile 'digital.tail.sdk.tail_mobile_sdk:tail-mobile-sdk:1.2.+'</b>

}
</pre>


<h2 id="atualizar-security-providers-do-google-play-services-em-android-4-x">Atualizar Security Providers  do Google Play Services em Android 4.x</h2>
<p>Dispositivos com sistema operacional Android menor que a versão 5.0 (api 21) podem estar utilizando bibliotecas de comunicação em rede obsoletas e inseguras.
Neste caso, sugerimos que peça ao usuário que atualize a versão do dos Providers do Google Play Services do dispositivo utilizando a atualização de patch automática.</p>
<p>O manual de desenvolvedor do Android, no tópico &quot;Aplicação de patch assíncrona&quot;, descreve como implementar a <strong>atualização automática</strong> do Goolgle PlayServices em seu aplicativo. </p>
<p>Segue abaixo o link do tópico do manual:
<a href="https://developer.android.com/training/articles/security-gms-provider.html">https://developer.android.com/training/articles/security-gms-provider.html</a></p>
<p><strong>Atenção: Por motivo de segurança, não coletamos e nem enviamos dados do dispositivo caso não possua uma versão atualizada do Google Play Service</strong>. </p>
<h2 id="utilizando-o-sdk-em-um-projeto">Utilizando o SDK em um projeto</h2>
<p>O SDK possui um ponto central de acesso às funcionalidades nomeado <em>TailDMP</em>.
Este objeto é um singleton e deve ser inicializado apenas uma vez passando o contexto da aplicação.</p>
<h4 id="configurar-o-sdk">Configurar o SDK</h4>
<p>Devemos definir alguns parametros de configuração do SDK. 
Abaixo um exemplo de configuração:</p>
<pre>    
//Reference to a textfield on user interface
public TextView user_txtV;    

//Initialize the SDK
TailDMP.initialize(getApplicationContext());


//Generate an userhash ID using an email provided by a text field 
TailDMP.getInstance().generateUserHashFromEmail(user_txtV.getText().toString());

// Set user as optin
TailDMP.getInstance().setOptin(true);

//interval, in minutes, to collect data from deivce 
int intervalToCollectData = 15;

//interval, in minutes, to send data to server 
int intervalToSendData = 120;

//Set interval that will fires up the collectDataJob and the sendDataJob (required)
TailDMP.getInstance().setIntervalToExecuteJob(intervalToCollectData,intervalToSendData);
</pre>


<p>Após configurar o SDK iniciamos o processo de coleta e envio automaticos de dados utilizando o método <em>startJob()</em>.
Utilizamos serviços de agendamento de execução nativos do Android (JobScheduler) para coletar e enviar dados.
Estes serviços <strong>rodam nos estados de foreground e background do app</strong>.</p>
<pre><code>//Start the job
TailDMP.getInstance().startJob();
</code></pre><p>Você pode iniciar o processo onde achar mais adequado, num click, ao abrir o app, após inicialização de seu app, etc.  </p>
<p>Abaixo segue um exemplo de configuração e uso do sdk.</p>
<p>Ex.</p>
<pre>
package tail.digital.app;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import digital.tail.sdk.tail_mobile_sdk.TailDMP;
import digital.tail.sdk.tail_mobile_sdk.exception.TailDMPException;
public class MainActivity extends AppCompatActivity {

    //Reference to a textfield on user interface
    public TextView user_txtV;    

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initApp();
    }
    private void initApp() {
        try {
            //Initialize the SDK
            TailDMP.initialize(getApplicationContext());

            // Set user as optin (required)
            TailDMP.getInstance().setOptin(true);

            //interval, in minutes, to collect data from deivce 
            int intervalToCollectData = 15;

            //interval, in minutes, to send data to server 
            int intervalToSendData = 120;

            //Set interval that will fires up the collectDataJob and the sendDataJob (required)
            TailDMP.getInstance().setIntervalToExecuteJob(intervalToCollectData,intervalToSendData);
        } catch (TailDMPException e) {                              
            e.printStackTrace();
        }

    }

    //clicks on a button to start the process
    public void startIt(View view){
        try {

             //Generate an userhash ID using an email provided by a text field 
            TailDMP.getInstance().generateUserHashFromEmail(user_txtV.getText().toString());

           //get the instance of TailDMP SDK and start automatic job  or send data 
            if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {

                //For Android 5.0 and greater  use this   
                TailDMP.getInstance().startJob();

            }else{

                //For Android 4.x use this
                TailDMP.getInstance().sendData("");

            }
        }catch (TailDMPException e) {
            e.printStackTrace();
        }
    }
}
</pre>


<p>Caso seja necessário parar o processo automático basta chamar o método <em>stopJob()</em>. 
Esta ação é opcional, a partir do momento que iniciamos o processo de coleta e envio todo o fluxo acontece automaticamente de acordo com o periodo indicado em <strong>setIntervalToExecuteJob(intervalToCollectData,intervalToSendData)</strong>.
<strong>Se por qualquer razão o serviço for parado, lembre-se de reiniciá-lo novamente ou a coleta e envio de dados nunca será feita.</strong></p>
<pre><code>//Stop The job
TailDMP.getInstance().stopJob();
</code></pre><h4 id="pedir-permiss-es-para-captura-de-dados-de-geolocaliza-o">Pedir permissões para captura de dados de geolocalização</h4>
<p>Para recuperarmos a geolocalização do dispositivo é necessário pedir permissão ao usuário.
Podemos utilizar o objeto helper do Android - ActivityCompat.requestPermissions para implementar este workflow.
Recomendamos que a permissão seja pedida antes de qualquer ação de coleta ou envio de dados, você pode solicitá-la no inicio da aplicação. </p>
<p>Ex.</p>
<pre>
package tail.digital.app;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;

import digital.tail.sdk.tail_mobile_sdk.TailDMP;
import digital.tail.sdk.tail_mobile_sdk.exception.TailDMPException;

public class MainActivity extends AppCompatActivity {

    //Reference to a textfield on user interface
    public TextView user_txtV;    

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initApp();

        <b>//ask user to grant permissions
        askPermission()</b>
    }

    private void initApp() {

        try {

            //Initialize the SDK
            TailDMP.initialize(getApplicationContext());

            // Set user as optin (required)
            TailDMP.getInstance().setOptin(true);

            //interval, in minutes, to collect data from deivce 
            int intervalToCollectData = 15;

            //interval, in minutes, to send data to server 
            int intervalToSendData = 120;

            //Set interval that will fires up the collectDataJob and the sendDataJob (required)
            TailDMP.getInstance().setIntervalToExecuteJob(intervalToCollectData,intervalToSendData);

        } catch (TailDMPException e) {                              
            e.printStackTrace();
        }

    }

    <b>private void askPermission(){

        //check if the user allow us to use some private resources of this device
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this,Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)
        {
            //We can add more than one  per requirement
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.ACCESS_COARSE_LOCATION},123);
        }        

    }</b>

    //clicks on a button to start the process
    public void startIt(View view){
        try {

            //Generate an userhash ID using an email provided by a text field 
            TailDMP.getInstance().generateUserHashFromEmail(user_txtV.getText().toString());

            //get the instance of TailDMP SDK and stop the job
            TailDMP.getInstance().startJob();
        }catch (TailDMPException e) {
            e.printStackTrace();
        }
    }
}
</pre>        

<p>Referencia: <a href="https://developer.android.com/training/permissions/requesting.html?hl=pt-br">https://developer.android.com/training/permissions/requesting.html?hl=pt-br</a></p>
<h4 id="enviar-dados-sem-agendamento-autom-tico">Enviar dados sem agendamento automático</h4>
<p>Podemos utilizar o SDK para coletar e enviar dados do dispositivo sem utilizar o mecanismo de agendamento automático.</p>
<p><strong>Este tipo de envio é o recomendado para todas as versões de Android 4</strong>.</p>
<p>Caso o usuário esteja utilizando Android 4 não esqueça de pedir para atualizar o Security Provider ver: <a href="#atualizar-security-providers-do-google-play-services-em-android-4-x">Atualizar Security Providers  do Google Play Services em Android 4.x </a></p>
<p>Para executar esta ação utilizaremos o método <strong>sendData(String tag)</strong> do SDK.
Note que é necessário enviar uma <strong>tag</strong> como parametro. O valor da tag deve conter no máximo 32 caracteres, pode ser um texto em branco, conter letras, números e os seguintes caracteres: <strong>-  _  .  =</strong> </p>
<p>Abaixo um exemplo de sua utilização.</p>
<p>Ex.</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initApp();
    }

    private void initApp() {

        try {

            //initializing TailDMP
            //Starts the SDK
            TailDMP.initialize(getApplicationContext());

            //Generate an userhash ID using an email provided by a text field 
            TailDMP.getInstance().generateUserHashFromEmail(user_txtV.getText().toString());

            // Set user as optin (required)
            TailDMP.getInstance().setOptin(true);

            //Send data to webservice without a scheduled job Service, passing an enpty string as tag.
            TailDMP.getInstance().sendData(&quot;&quot;);


        } catch (TailDMPException e) {
            e.printStackTrace();
        }
    }

}
</code></pre><h4 id="habilitar-modo-sandbox">Habilitar Modo Sandbox</h4>
<p>Para verificar os dados que estão sendo enviados para a TailTarget é necessário habilitar a opção de modo &quot;Sandbox&quot; no SDK.
Por padrão esta funcionalidade vem desabilitada.</p>
<p>Quando essa opção está habilitada os dados serão direcionados para um serviço que os descriptografa e os exibe na área de &quot;SDK SandBox&quot; do Dashboard da TailTarget.
Estes dados nunca serão processados, a função do modo Sandbox é prover uma interface para conferir se o SDK está configurado corretamente em seu app e se os dados estão sendo enviados com sucesso.</p>
<p>A área de Sandbox do Dashboard pode ser acessada pelo menu Configurações &gt; Configurações Avançadas &gt; SDK SandBox ou acessada pela URL: <a href="https://dashboard.tailtarget.com/dmp/#/sandbox">https://dashboard.tailtarget.com/dmp/#/sandbox</a></p>
<p><strong>ATENÇÃO! Antes de publicar o seu app com o SDK desabilite o modo SandBox ou os dados enviados por seu app nunca serão processados.</strong> </p>
<p>Abaixo um exemplo de como habilitar o modo Sandbox:</p>
<pre>
    //initialize SDK
    TailDMP.initialize(getApplicationContext());
    //set user as optin
    TailDMP.getInstance().setOptin(true);

    //enable SANDBOX MODE
    // Don't forget to disable this mode before You publish the app
    <strong>TailDMP.getInstance().enableSandbox(true);
    </strong>
</pre>    


<p>Abaixo um exemplo de como desabilitar o modo Sandbox:</p>
<pre>
    //disable SANDBOX MODE
    <strong>TailDMP.getInstance().enableSandbox(false)</strong>
</pre>









<h4 id="adicionar-tags-ao-envio-autom-tico-do-sdk">Adicionar Tags Ao envio automático do SDK</h4>
<p>Tags são informações extras que podem ser enviadas para o webservice.
A informação não pode ser vazia, deve ter no máximo 32 caracteres, pode conter letras, números e os seguintes caracteres especiais: - _ . = </p>
<p>Deve ser do tipo String e ao adicioná-la ao SDK é criado um novo registro que será enviado automaticamente para nossos servidores.</p>
<p>Ex.</p>
<pre><code>//We must get the instance initialized
try{
    tDMP = TailDMP.getInstance();
}catch (TailDMPException e) {
    e.printStackTrace();
}

String mytag = &quot;onlineChannel&quot;;

if(tDMP != null)
tDMP.addTags(mytag);
</code></pre><h2 id="beacons">BEACONS</h2>
<h4 id="configurando-beacons-para-serem-detectados-pelo-taildmp-sdk">Configurando Beacons para serem detectados pelo TailDMP SDK</h4>
<p>Nossa biblioteca pode ser utilizada para detectar beacons, porém esta funcionalidade está disponível apenas nas versões de <strong>android api  &gt;=21</strong></p>
<p>O SDK suporta o protocolo <a href="https://developers.google.com/beacons/eddystone" target="_blank"><b>Eddystone-UID</b></a>
 que possui um identificador único de formato de mensagem para cada dispositivo. 
O identificador é dividido de duas partes, <em>Namespace</em> (10 bytes) e  <em>Instance</em> (6 bytes).</p>
<p>O Namespace é utilizado para filtrar seus beacons de outros existentes na área e o Instance para identificar e diferenciar cada um dos seus beacons.   </p>
<p>Para seu beacon ser detectado pelo nosso SDK é obrigatório que no formato de mensagem o  <strong>Namespace</strong> possua o valor de <strong>CFB3DBE6A3E1B065C4BB</strong>.</p>
<p>O valor de <strong>Instance</strong> pode ser personalizado para cada dispositivo ex: 112233445566, 112233445567 .</p>
<p>O beacon deverá emitir um sinal com o protocolo Eddystone-UID semelhante ao exemplo abaixo:</p>
<pre>
Ex: CFB3DBE6A3E1B065C4BB112233445566
</pre>

<p>Utilizamos a biblioteca &quot;Nearby&quot; do Google para controlar o processo de procura por beacons no dispositivo do usuário. Para o correto funcionamento, o serviço geolocalização deve estar habilitado pelo usuário.</p>
<p>A procura por beacons é iniciada nos eventos <em>ON/OFF</em> de tela do Android. </p>
<p>A detecção dos Beacons <strong>depende do bluetooth estar ativo</strong> aconselhamos que na sua estratégia de construção do App inclua mecanismos que estimulem o usuário a mantê-lo ligado.</p>
<p>É necessário nos enviar todos os InstanceIds criados para podermos registra-los e fazer o rastreamento correto pelo SDK.</p>
<h2 id="configurar-o-sdk-para-detectar-beacons">Configurar o SDK para detectar beacons</h2>
<h3 id="configura-es-requeridas">Configurações requeridas</h3>
<h4 id="permiss-es-no-androidmanifest">Permissões no AndroidManifest</h4>
<p>Adicionar as seguintes permissões ao AndroidManifest.xml</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;

&lt;uses-permission android:name=&#39;android.permission.BLUETOOTH&#39;/&gt;
&lt;uses-permission android:name=&#39;android.permission.BLUETOOTH_ADMIN&#39;/&gt;
&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt;

&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;

&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
&lt;uses-permission android:name=&quot;com.google.android.gms.permission.ACTIVITY_RECOGNITION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre><p>Adicionar os serviços abaixo dentro da tag aplication</p>
<pre><code>&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPCollectDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Collect Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPSendALLDataJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Tail DMP Send All Data Service&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.CheckNearByJobService&quot;  android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; android:label=&quot;Check beacon activity&quot;/&gt;
&lt;service android:name=&quot;digital.tail.sdk.tail_mobile_sdk.TailDMPActivityTrackerIntentService&quot; android:exported=&quot;false&quot; android:label=&quot;Tail DMP Activity Service&quot; /&gt;
</code></pre><h4 id="configura-es-graddle">Configurações graddle</h4>
<p>Para o correto funcionamento do SDK utilizamos bibliotecas do google play service, elas devem ser compiladas junto com aplicativo. 
Devemos adicionar as bibliotecas com.google.android.gms:play-services-nearby, play-services-location e incorporar o SDK como dependências do gradle.build. </p>
<p>Abaixo um exemplo de como ficaria a configuração do dependencies do arquivo gradle.build.</p>
<pre>

apply plugin: 'com.android.application'
android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
    defaultConfig {
        applicationId "tail.digital.app"
        minSdkVersion 21
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"

    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])

    //import google play libs
    compile 'com.google.android.gms:play-services-identity:11.0.4'
    <b>compile 'com.google.android.gms:play-services-location:11.0.4'
    compile 'com.google.android.gms:play-services-nearby:11.0.4'
    </b>

    compile 'com.android.support:appcompat-v7:25.3.1'
    compile 'com.android.support.constraint:constraint-layout:1.0.2'
    //add and extract the sdk from mavencentral
    //change 1.2.+ to the latest version available
    <b>compile 'digital.tail.sdk.tail_mobile_sdk:tail-mobile-sdk:1.2.+'</b>
}

</pre>





<h4 id="habilitar-rastreamento-de-beacons-no-app">Habilitar rastreamento de beacons no App</h4>
<p>O rastreamento de beacons é habilitado automáticamente ao utilizar o método de coleta e envio de dados automático <strong>TailDMP.getInstance().startJob()</strong> ou utilizando o método manual <strong>TailDMP.getInstance().enableBeaconScan()</strong>. </p>
<p>A detecção só acontece caso o usuário seja optin, dê <a href="#permission">permissão</a> para acesso à geolocalização e o bluetooth do dispositivo esteja ativo. </p>
<p>Todos os dados coletados dos beacons são salvos no app e só são enviados para Tail através do serviço de coleta e envio de dados automático, portanto <strong>você deve &quot;rodar&quot; o SDK no modo automático</strong>.</p>
<p>A busca por beacons acontece quando o App está nos estados de foreground e background, o processo roda em uma thread em background, não bloqueia a interface do usuário e utiliza apenas <strong>Bluetooth Low Energy (BLE)</strong> para preservar a carga de bateria. </p>
<p><strong>Não esqueça de habilitar o envio automático ou não receberemos os dados sobre os beacons.</strong> </p>
<p>Abaixo segue um exemplo de como habilitar o rastreamento de beacons, do workkflow para pedir permissão de uso de dados de geolocalização e iniciar o processo automático de coleta e envio de dados:</p>
<pre>
package digital.tail.apptrackbeacons;

import android.Manifest;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.support.annotation.NonNull;
import android.support.design.widget.Snackbar;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.nearby.messages.MessageListener;

import digital.tail.sdk.tail_mobile_sdk.TailDMP;
import digital.tail.sdk.tail_mobile_sdk.TailDMPValues;
import digital.tail.sdk.tail_mobile_sdk.exception.TailDMPException;


//We need to handle PermissionsResultCallback so we implement its methods in this activity
public class MainActivity extends AppCompatActivity implements ActivityCompat.OnRequestPermissionsResultCallback{

    private int PERMISSION_REQUEST_ID = 123;

    TextView txt_email;

    Button btEnablebeacon;
    Button btDisablebeacon;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //get email textfield
        txt_email = (TextView)findViewById(R.id.txt_email);


        //get beacons bts
        btEnablebeacon = (Button) findViewById(R.id.btEnablebeacon);
        btDisablebeacon = (Button) findViewById(R.id.btDisablebeacon);

        //setcolors
        btEnablebeacon.setBackgroundColor(Color.parseColor("#4caf50"));
        btEnablebeacon.setTextColor(Color.parseColor("#FFFFFF"));

        btDisablebeacon.setBackgroundColor(Color.parseColor("#f44336"));
        btDisablebeacon.setTextColor(Color.parseColor("#FFFFFF"));


        //initialize TailDMP SDK
        initApp();
    }



    /****************************
     *
     * Initializing Tal DMP SDK
     *
     ***************************/
    private void initApp(){

        //initializing TailDMP

        try {
            TailDMP.initialize(getApplicationContext());
            //set user as optin
            TailDMP.getInstance().setOptin(true);


        } catch (TailDMPException e) {
            e.printStackTrace();
        }


    }


    /****************************
     *
     * Initializing Beacons tracking
     *
     ***************************/
    public void initBeacons(View view){

        //just initialize if we have location permission granted
        if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED) {
            //init beacons tracking
            try {

                //generate user hash
                TailDMP.getInstance().generateUserHashFromEmail(txt_email.getText().toString());
                <b>
                //enable beacon tracking manually
                TailDMP.getInstance().enableBeaconScan(this);
                </b>

                /****************************************************************************
                 *
                 * Don't forget to start the service to automatically collect and send data
                 * or it will never be sent to be processed by us.
                 *
                *****************************************************************************/
                //collect and send data
                startSendDataService();

            } catch (TailDMPException e) {
                e.printStackTrace();
            }
        }else{
            //ask permission

            View v = findViewById(android.R.id.content);
            checkPermission(v);
        }
    }


    /****************************
     *
     * Stops Beacons tracking
     *
     ***************************/
    public void disableBeacons(View v){

        try {
            //stops tracking beacons
            TailDMP.getInstance().disableBeaconScan();




        } catch (TailDMPException e) {
            e.printStackTrace();
        }


    }

    /****************************
     *
     * Stars automatic service that collect and send data
     *
     ***************************/
    private void startSendDataService(){
        try {
            //every 15 minutes try to collect data
            //every 480(8 hours) minutes try to send data to server
           <b>TailDMP.getInstance().setIntervalToExecuteJob(15,480);</b>
            //initialize beacon tracking automatically
            <b>TailDMP.getInstance().startJob();</b>

        } catch (TailDMPException e) {
            e.printStackTrace();
        }
    }


    /****************************
     *
     * Stops automatic service that collect and send data
     *
     ***************************/
    private void stopSendDataService(){
        try {

            TailDMP.getInstance().stopJob();

        } catch (TailDMPException e) {
            e.printStackTrace();
        }
    }



    // =============================
    // ==>> ASK PERMISSION TO USER
    // =============================
    //https://developer.android.com/training/permissions/requesting.html



    /****************************
     *
     * Ask permission dialog for user interaction
     *
     ***************************/
    public void checkPermission(View view){
        //check if the user allow us to use some private resources of this device
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this,Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED
                ){
            //Can add more as per requirement
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.ACCESS_COARSE_LOCATION},PERMISSION_REQUEST_ID);
        }
    }


    /****************************
     *
     * Handler of Dialog's action
     *
     ***************************/
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {

        if (requestCode == PERMISSION_REQUEST_ID) {

            int PERMISSION_GRANTED = -1;

            //loop through all permissions requested
            for(int i = 0; i<permissions.length; i++){

                //found ACCESS_COARSE_LOCATION
                if(permissions[i].equals("android.permission.ACCESS_COARSE_LOCATION")){
                    PERMISSION_GRANTED = grantResults[i];
                    break;
                }

            }

            // Check if the required permission has been granted
            if (PERMISSION_GRANTED == PackageManager.PERMISSION_GRANTED) {
                <b>// access to locations device granted
                //start beacon tracking
                initBeacons(null);
                </b>
            } else {

                Snackbar.make(this.findViewById(android.R.id.content), "You must grant permission to access device location if you want to use this feature!",
                        Snackbar.LENGTH_LONG).show();

            }

        }else{
            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        }


    }
}


</pre>




<h2 id="sum-rio-de-classes">Sumário de Classes</h2>
<h3 id="taildmp">TailDMP</h3>
<blockquote>
<p>Objeto de acesso central das funcionalidades do SDK
Este objeto é um singleton e deve ser inicializado apenas uma vez passando o contexto da aplicação.</p>
</blockquote>
<table >
 <thead>
  <tr>
   <th colspan="2">Construtor</th>
  </tr>
 </thead>

 <tbody>
  <tr>
   <td>
    <pre>initialize(Context context)</pre>
  </td>
  <td>
   <p>Método para inicializar o Singleton TailDMP, deve ser inicializado apenas uma vez. Obrigatório</p>
  </td>
 </tr>
 </tbody>
</table>

<table><br> <thead>
  <tr>
  <th colspan="2">Métodos públicos</th>
  </tr>
 </thead>
 <tbody>

  <tr>
   <td ><pre>enableSandbox(boolean enable) </pre></td>
   <td>
    <p>Habilita/Desabilita o modo Sandbox. </p>
    <p>Modo desabilitado Por padrão.</p>
     <p>Quando Habilitado, os dados são enviados para um serviço que descriptografa e os exibe na área de Sandbox do Dashboard.</p>
    <p>Utilizado para verificar se a configuração do app está correta e os dados foram enviados para a TailTarget</p>
   </td>
  </tr>

  <tr>
   <td ><pre>getInstance() </pre></td>
   <td>
    <p>Recupera a instancia do TailDMP inicializada</p>
   </td>
  </tr><br>  <tr>
   <td ><pre>generateUserHashFromEmail(String useremail) </pre></td>
   <td>
    <p>Gera um hash identificador do usuário utilizando um email. O valor deve estar em caixa baixa e ser um endereço válido.</p>
   </td>
  </tr>

  <tr>
     <td ><pre>generateUserHashFromCPF(String CPF) </pre></td>
     <td>
      <p>Gera um hash identificador utilizando o CPF, o valor deve conter apenas os 11 digitos</p>
      <p>Ex. 111.111.111-11 =&gt; 11111111111</p>
      <p>Reference: <a href="https://dashboard.tailtarget.com/dmp/#/docs/a10">https://dashboard.tailtarget.com/dmp/#/docs/a10</a></p>
     </td>
    </tr>

  <tr>
       <td ><pre>generateUserHashFromPhone(String phonenumber) </pre></td>
       <td>
        <p>Gera um hash identificador utilizando um numero de telefone, o valor deve conter apenas digitos e o número de telefone deve ser o internacional sem os digitos de operadoras.</p>
         <p>Ex. 11982235000 =&gt; 5511982235000
8587719999 =&gt; 558587719999</p>
       <p>Reference: <a href="https://dashboard.tailtarget.com/dmp/#/docs/a10">https://dashboard.tailtarget.com/dmp/#/docs/a10</a></p>
       </td>
      </tr>


  <tr>
   <td ><pre>addTags(Strig tag) </pre></td>
   <td>
    <p>Adiciona informações extra para enviar ao server</p>
    <p><b>tag</b> - String de no máximo 32 caracteres, <b>não</b> pode ser vazia, pode conter letras, digitos e os caracteres: . - <em> = </p>
   </td>
  </tr><br>  <tr>
   <td ><pre>sendData(String tag) </pre></td>
   <td>
    <p>Envia dados do device sem o mecanismo de agendamento automático</p>
    <p><b>tag</b> - String de no máximo 32 caracteres, pode ser vazia, pode conter letras, digitos e os caracteres: . - </em> = </p>
   </td>
  </tr>
  <tr>
   <td ><pre>setIntervalToExecuteJob(int minutesToCollect, int minutesToSend) </pre></td>
   <td>
   <p>Define os tempos de coleta e envio de dados. </p>
    <p><b>minutesToCollect</b> - Adicionar um intervalo de tempo, em minutos, para o serviço de coleta de dados. O tempo mínimo entre as coletas deve ser de 15 minutos</p>
    <p><b>minutesToSend</b> - Adicionar um intervalo de tempo, em minutos, para o serviço de envio dados ao servidor. O tempo mínimo para os envios deve ser maior que o de coleta e de até 24hs </p>
   </td>
  </tr>
  <tr>
   <td ><pre>startJob() </pre></td>
   <td>
    <p>Inicia o agendamento dos serviços de envio e coleta de dados periodicamente respeitando os intervalos de tempo definidos no método setIntervalToExecuteJob(int minutesToCollect, int minutesToSend)</p>
   </td>
  </tr>
  <tr>
   <td ><pre>stopJob() </pre></td>
   <td>
    <p>Interrompe a execução do servico de coleta e envio de dados automáticos. <b>(Opcional)</b></p>
   </td>
  </tr>

  <tr>
     <td ><pre>setOptin(boolean) </pre></td>
     <td>
      <p>true | false - Autoriza ou não o envio e coleta de dados, o padrão é true.</p>
     </td>
    </tr><br>
  <tr>
   <td ><pre>setSendDataOnWifiOnly(boolean) </pre></td>
       <td>
        <p>true | false - Sinaliza ao SDK que o envio de dados será feito apenas se o usuário estiver conectado em uma rede wifi, o padrão é false.</p>
       </td>
      </tr><br>



<tr>
   <td ><pre>enableBeaconScan(Activity act) </pre></td>
   <td>
    <p>
        Habilitar o rastreamento e detecção de Beacons.
    </p>
   </td>
  </tr>
<tr>
   <td ><pre>disableBeaconScan() </pre></td>
   <td>
    <p>
        Desliga o rastreamento de Beacons.
    </p>
   </td>
  </tr>


 </tbody>
</table>

</article></body></html>